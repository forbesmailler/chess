"""Generate engine/generated_config.h from YAML config files."""

import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
from config.load_config import load

ROOT = Path(__file__).resolve().parent.parent
OUTPUT = ROOT / "engine" / "generated_config.h"


def flatten_pst(rows: list[list[int]]) -> list[int]:
    return [v for row in rows for v in row]


def fmt_int_array(values: list[int], name: str, indent: str) -> str:
    vals = ", ".join(str(v) for v in values)
    return f"{indent}static constexpr int {name}[] = {{{vals}}};\n"


def fmt_pst(values: list[int], name: str, indent: str) -> str:
    """Format a 64-element PST array with 8 values per line."""
    lines = []
    lines.append(f"{indent}static constexpr int {name}[64] = {{")
    for rank in range(8):
        row = values[rank * 8 : (rank + 1) * 8]
        vals = ", ".join(f"{v:4d}" for v in row)
        comma = "," if rank < 7 else ""
        lines.append(f"{indent}    {vals}{comma}")
    lines.append(f"{indent}}};")
    return "\n".join(lines) + "\n"


def generate() -> str:
    eng = load("engine")
    evl = load("eval")
    trn = load("training")

    lines = []
    lines.append("// Auto-generated by scripts/gen_config_header.py -- DO NOT EDIT")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <cstddef>")
    lines.append("#include <string_view>")
    lines.append("")
    lines.append("namespace config {")
    lines.append("")
    lines.append(f"static constexpr float MATE_VALUE = {eng['mate_value']:.1f}f;")
    lines.append("")

    # nnue
    lines.append("namespace nnue {")
    for k in (
        "input_size",
        "hidden1_size",
        "max_hidden1_size",
        "hidden2_size",
        "max_hidden2_size",
        "output_size",
    ):
        name = k.upper()
        lines.append(f"    static constexpr int {name} = {trn['nnue'][k]};")
    lines.append("}  // namespace nnue")
    lines.append("")

    # search
    s = eng["search"]
    lines.append("namespace search {")
    tt_log2 = s["tt_size_log2"]
    lines.append(f"    static constexpr size_t TT_SIZE = 1 << {tt_log2};")
    lines.append("    static constexpr size_t TT_MASK = TT_SIZE - 1;")
    ec_log2 = s["eval_cache_size_log2"]
    lines.append(f"    static constexpr size_t EVAL_CACHE_SIZE = 1 << {ec_log2};")
    lines.append("    static constexpr size_t EVAL_CACHE_MASK = EVAL_CACHE_SIZE - 1;")
    lines.append(
        f"    static constexpr int TIME_CHECK_INTERVAL = {s['time_check_interval']};"
    )
    lines.append(f"    static constexpr int MAX_DEPTH = {s['max_depth']};")
    lines.append(
        f"    static constexpr int QUIESCENCE_MAX_DEPTH = {s['quiescence_max_depth']};"
    )
    lines.append(
        f"    static constexpr int TIME_ALLOCATION_DIVISOR = {s['time_allocation_divisor']};"
    )
    lines.append(f"    static constexpr int MIN_TIME_MS = {s['min_time_ms']};")
    lines.append(f"    static constexpr int MAX_TIME_MS = {s['max_time_ms']};")
    lines.append(
        f"    static constexpr float ASPIRATION_DELTA = {s['aspiration_delta']:.1f}f;"
    )
    lines.append(
        f"    static constexpr int ASPIRATION_MIN_DEPTH = {s['aspiration_min_depth']};"
    )
    lines.append(
        f"    static constexpr int MATE_THRESHOLD_MARGIN = {s['mate_threshold_margin']};"
    )
    lines.append("")
    nm = s["null_move"]
    lines.append("    namespace null_move {")
    lines.append(f"        static constexpr int MIN_DEPTH = {nm['min_depth']};")
    lines.append(f"        static constexpr int MATE_MARGIN = {nm['mate_margin']};")
    lines.append(
        f"        static constexpr int DEEP_THRESHOLD = {nm['deep_threshold']};"
    )
    lines.append(
        f"        static constexpr int SHALLOW_REDUCTION = {nm['shallow_reduction']};"
    )
    lines.append(
        f"        static constexpr int DEEP_REDUCTION = {nm['deep_reduction']};"
    )
    lines.append("    }  // namespace null_move")
    lines.append("")
    lmr = s["lmr"]
    lines.append("    namespace lmr {")
    lines.append(
        f"        static constexpr int MIN_MOVES_SEARCHED = {lmr['min_moves_searched']};"
    )
    lines.append(f"        static constexpr int MIN_DEPTH = {lmr['min_depth']};")
    lines.append(
        f"        static constexpr int MANY_MOVES_THRESHOLD = {lmr['many_moves_threshold']};"
    )
    lines.append(
        f"        static constexpr int SHALLOW_REDUCTION = {lmr['shallow_reduction']};"
    )
    lines.append(
        f"        static constexpr int DEEP_REDUCTION = {lmr['deep_reduction']};"
    )
    lines.append("    }  // namespace lmr")
    lines.append("")
    ms = s["move_scoring"]
    lines.append("    namespace move_scoring {")
    ms_pv = ms["piece_values"]
    pv_vals = ", ".join(str(v) for v in ms_pv)
    lines.append(f"        static constexpr int PIECE_VALUES[] = {{{pv_vals}}};")
    lines.append(f"        static constexpr int TT_MOVE_BONUS = {ms['tt_move_bonus']};")
    lines.append(
        f"        static constexpr int CAPTURE_BASE_SCORE = {ms['capture_base_score']};"
    )
    lines.append(
        f"        static constexpr int PROMOTION_BONUS = {ms['promotion_bonus']};"
    )
    lines.append(f"        static constexpr int KILLER1_BONUS = {ms['killer1_bonus']};")
    lines.append(f"        static constexpr int KILLER2_BONUS = {ms['killer2_bonus']};")
    lines.append(
        f"        static constexpr int COUNTERMOVE_BONUS = {ms['countermove_bonus']};"
    )
    lines.append(f"        static constexpr int HISTORY_MAX = {ms['history_max']};")
    lines.append(
        f"        static constexpr int VICTIM_VALUE_MULTIPLIER = {ms['victim_value_multiplier']};"
    )
    lines.append("    }  // namespace move_scoring")
    lines.append("")
    tt_repl = s["tt_replacement"]
    lines.append("    namespace tt_replacement {")
    lines.append(
        f"        static constexpr int DEPTH_WEIGHT = {tt_repl['depth_weight']};"
    )
    lines.append(
        f"        static constexpr int EXACT_BONUS = {tt_repl['exact_bonus']};"
    )
    lines.append("    }  // namespace tt_replacement")
    lines.append("")
    pr = s["pruning"]
    lines.append("    namespace pruning {")
    lines.append(
        f"        static constexpr float REVERSE_FUTILITY_MARGIN = {pr['reverse_futility_margin']:.1f}f;"
    )
    lines.append(
        f"        static constexpr float FUTILITY_MARGIN_DEPTH1 = {pr['futility_margin_depth1']:.1f}f;"
    )
    lines.append(
        f"        static constexpr float FUTILITY_MARGIN_DEPTH2 = {pr['futility_margin_depth2']:.1f}f;"
    )
    lines.append(f"        static constexpr int LMP_BASE = {pr['lmp_base']};")
    lines.append("    }  // namespace pruning")
    lines.append("")
    qs = s["quiescence"]
    lines.append("    namespace quiescence {")
    qs_pv = qs["piece_values"]
    qs_vals = ", ".join(f"{v:.1f}f" for v in qs_pv)
    lines.append(f"        static constexpr float PIECE_VALUES[] = {{{qs_vals}}};")
    lines.append(
        f"        static constexpr float DELTA_MARGIN = {qs['delta_margin']:.1f}f;"
    )
    lines.append(
        f"        static constexpr float EN_PASSANT_VALUE = {qs['en_passant_value']:.1f}f;"
    )
    lines.append("    }  // namespace quiescence")
    lines.append("}  // namespace search")
    lines.append("")

    # mcts
    m = eng["mcts"]
    lines.append("namespace mcts {")
    lines.append(
        f"    static constexpr float EXPLORATION_CONSTANT = {m['exploration_constant']:.1f}f;"
    )
    lines.append(
        f"    static constexpr int MAX_SIMULATION_DEPTH = {m['max_simulation_depth']};"
    )
    lines.append(f"    static constexpr int EVAL_FREQUENCY = {m['eval_frequency']};")
    lines.append(
        f"    static constexpr float EARLY_TERMINATION_FACTOR = {m['early_termination_factor']:.1f}f;"
    )
    lines.append(
        f"    static constexpr float PRIOR_SIGMOID_SCALE = {m['prior_sigmoid_scale']:.1f}f;"
    )
    lines.append(
        f"    static constexpr int NODE_COUNT_INTERVAL = {m['node_count_interval']};"
    )
    lines.append("}  // namespace mcts")
    lines.append("")

    # bot
    b = eng["bot"]
    lines.append("namespace bot {")
    lines.append(f"    static constexpr int MAX_RETRIES = {b['max_retries']};")
    lines.append(f"    static constexpr int RETRY_DELAY_MS = {b['retry_delay_ms']};")
    lines.append(
        f"    static constexpr int HEARTBEAT_INTERVAL_MS = {b['heartbeat_interval_ms']};"
    )
    lines.append(
        f"    static constexpr int CONNECTION_TIMEOUT_MS = {b['connection_timeout_ms']};"
    )
    lines.append(
        f"    static constexpr int MAX_CONSECUTIVE_ERRORS = {b['max_consecutive_errors']};"
    )
    lines.append(f"    static constexpr int MAX_RESTARTS = {b['max_restarts']};")
    lines.append(
        f"    static constexpr int MAX_GAME_STREAM_RETRIES = {b['max_game_stream_retries']};"
    )
    lines.append(
        f"    static constexpr int GAME_STREAM_RECONNECT_DELAY_S = {b['game_stream_reconnect_delay_s']};"
    )
    lines.append(
        f"    static constexpr int DRAW_RESPONSE_RETRY_DELAY_MS = {b['draw_response_retry_delay_ms']};"
    )
    lines.append(
        f"    static constexpr int MOVE_RETRY_DELAY_MS = {b['move_retry_delay_ms']};"
    )
    lines.append(
        f'    static constexpr std::string_view USER_AGENT = "{b["user_agent"]}";'
    )
    lines.append(
        f'    static constexpr std::string_view LICHESS_BASE_URL = "{b["lichess_base_url"]}";'
    )
    lines.append(
        f'    static constexpr std::string_view CONNECTIVITY_TEST_URL = "{b["connectivity_test_url"]}";'
    )
    lines.append("}  // namespace bot")
    lines.append("")

    # curl
    c = eng["curl"]
    lines.append("namespace curl {")
    lines.append(
        f"    static constexpr long REQUEST_TIMEOUT = {c['request_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long REQUEST_CONNECT_TIMEOUT = {c['request_connect_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long CONNECTIVITY_TIMEOUT = {c['connectivity_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long CONNECTIVITY_CONNECT_TIMEOUT = {c['connectivity_connect_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_CONNECT_TIMEOUT = {c['stream_connect_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_LOW_SPEED_LIMIT = {c['stream_low_speed_limit']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_LOW_SPEED_TIME = {c['stream_low_speed_time']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_KEEPALIVE_IDLE = {c['stream_keepalive_idle']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_KEEPALIVE_INTERVAL = {c['stream_keepalive_interval']}L;"
    )
    lines.append(f"    static constexpr long MAX_REDIRECTS = {c['max_redirects']}L;")
    lines.append("}  // namespace curl")
    lines.append("")

    # eval
    lines.append("namespace eval {")
    ind = "    "
    lines.append(fmt_int_array(evl["material_mg"], "MATERIAL_MG", ind))
    lines.append(fmt_int_array(evl["material_eg"], "MATERIAL_EG", ind))
    lines.append(fmt_int_array(evl["phase_weight"], "PHASE_WEIGHT", ind))
    # Derived: TOTAL_PHASE = 4*N + 4*B + 4*R + 2*Q = 4*1 + 4*1 + 4*2 + 2*4
    pw = evl["phase_weight"]
    total_phase = 4 * pw[1] + 4 * pw[2] + 4 * pw[3] + 2 * pw[4]
    lines.append(f"{ind}static constexpr int TOTAL_PHASE = {total_phase};")
    lines.append("")
    lines.append(fmt_int_array(evl["mobility_bonus"], "MOBILITY_BONUS", ind))

    # PSTs
    pst_names = [
        ("pst_pawn_mg", "PST_PAWN_MG"),
        ("pst_pawn_eg", "PST_PAWN_EG"),
        ("pst_knight_mg", "PST_KNIGHT_MG"),
        ("pst_knight_eg", "PST_KNIGHT_EG"),
        ("pst_bishop_mg", "PST_BISHOP_MG"),
        ("pst_bishop_eg", "PST_BISHOP_EG"),
        ("pst_rook_mg", "PST_ROOK_MG"),
        ("pst_rook_eg", "PST_ROOK_EG"),
        ("pst_queen_mg", "PST_QUEEN_MG"),
        ("pst_queen_eg", "PST_QUEEN_EG"),
        ("pst_king_mg", "PST_KING_MG"),
        ("pst_king_eg", "PST_KING_EG"),
    ]
    for yaml_key, cpp_name in pst_names:
        lines.append(fmt_pst(flatten_pst(evl[yaml_key]), cpp_name, ind))

    # PST lookup arrays
    lines.append(
        f"{ind}static constexpr const int* PST_MG[] = {{PST_PAWN_MG, PST_KNIGHT_MG, PST_BISHOP_MG,"
    )
    lines.append(
        f"{ind}                                         PST_ROOK_MG, PST_QUEEN_MG, PST_KING_MG}};"
    )
    lines.append(
        f"{ind}static constexpr const int* PST_EG[] = {{PST_PAWN_EG, PST_KNIGHT_EG, PST_BISHOP_EG,"
    )
    lines.append(
        f"{ind}                                         PST_ROOK_EG, PST_QUEEN_EG, PST_KING_EG}};"
    )
    lines.append("")

    # Pawn structure
    ps = evl["pawn_structure"]
    lines.append(f"{ind}namespace pawn_structure {{")
    lines.append(f"{ind}    static constexpr int PASSED_BASE = {ps['passed_base']};")
    lines.append(
        f"{ind}    static constexpr int PASSED_RANK_SCALE = {ps['passed_rank_scale']};"
    )
    lines.append(
        f"{ind}    static constexpr int PASSED_MG_DIVISOR = {ps['passed_mg_divisor']};"
    )
    lines.append(f"{ind}    static constexpr int ISOLATED_MG = {ps['isolated_mg']};")
    lines.append(f"{ind}    static constexpr int ISOLATED_EG = {ps['isolated_eg']};")
    lines.append(f"{ind}    static constexpr int DOUBLED_MG = {ps['doubled_mg']};")
    lines.append(f"{ind}    static constexpr int DOUBLED_EG = {ps['doubled_eg']};")
    lines.append(f"{ind}}}  // namespace pawn_structure")
    lines.append("")

    # Rook file
    rf = evl["rook_file"]
    lines.append(f"{ind}namespace rook_file {{")
    lines.append(f"{ind}    static constexpr int OPEN_MG = {rf['open_mg']};")
    lines.append(f"{ind}    static constexpr int OPEN_EG = {rf['open_eg']};")
    lines.append(f"{ind}    static constexpr int SEMI_OPEN_MG = {rf['semi_open_mg']};")
    lines.append(f"{ind}    static constexpr int SEMI_OPEN_EG = {rf['semi_open_eg']};")
    lines.append(f"{ind}}}  // namespace rook_file")
    lines.append("")

    # Bishop pair
    bp = evl["bishop_pair"]
    lines.append(f"{ind}namespace bishop_pair {{")
    lines.append(f"{ind}    static constexpr int BONUS_MG = {bp['bonus_mg']};")
    lines.append(f"{ind}    static constexpr int BONUS_EG = {bp['bonus_eg']};")
    lines.append(f"{ind}}}  // namespace bishop_pair")
    lines.append("")

    # King safety
    ks = evl["king_safety"]
    lines.append(f"{ind}namespace king_safety {{")
    lines.append(
        f"{ind}    static constexpr int SHIELD_BONUS_MG = {ks['shield_bonus_mg']};"
    )
    lines.append(f"{ind}}}  // namespace king_safety")
    lines.append("")
    lines.append(
        f"{ind}static constexpr float SIGMOID_SCALE = {evl['sigmoid_scale']:.1f}f;"
    )
    lines.append("}  // namespace eval")
    lines.append("")

    # self_play
    sp = trn["self_play"]
    lines.append("namespace self_play {")
    lines.append(f"    static constexpr int NUM_GAMES = {sp['num_games']};")
    lines.append(f"    static constexpr int NUM_THREADS = {sp['num_threads']};")
    lines.append(f"    static constexpr int SEARCH_TIME_MS = {sp['search_time_ms']};")
    lines.append(f"    static constexpr int RANDOM_PLIES = {sp['random_plies']};")
    lines.append(f"    static constexpr int SOFTMAX_PLIES = {sp['softmax_plies']};")
    lines.append(
        f"    static constexpr float SOFTMAX_TEMPERATURE = {sp['softmax_temperature']:.1f}f;"
    )
    lines.append(
        f"    static constexpr int PROGRESS_LOG_INTERVAL = {sp['progress_log_interval']};"
    )
    lines.append("}  // namespace self_play")
    lines.append("")

    # compare
    cmp = trn.get("compare", {})
    lines.append("namespace compare {")
    lines.append(f"    static constexpr int NUM_GAMES = {cmp.get('num_games', 100)};")
    lines.append("}  // namespace compare")
    lines.append("")

    lines.append("}  // namespace config")
    lines.append("")

    return "\n".join(lines)


def main():
    content = generate()
    OUTPUT.write_text(content)
    print(f"Generated {OUTPUT}")


if __name__ == "__main__":
    main()
