"""Generate engine/generated_config.h from YAML config files."""

from pathlib import Path

import yaml

ROOT = Path(__file__).resolve().parent.parent
CONFIG_DIR = ROOT / "config"
OUTPUT = ROOT / "engine" / "generated_config.h"


def load(name: str) -> dict:
    with open(CONFIG_DIR / f"{name}.yaml") as f:
        return yaml.safe_load(f)


def flatten_pst(rows: list[list[int]]) -> list[int]:
    """Flatten 8x8 PST from YAML into 64-element list."""
    return [v for row in rows for v in row]


def fmt_int_array(values: list[int], name: str, indent: str) -> str:
    """Format a constexpr int array."""
    vals = ", ".join(str(v) for v in values)
    return f"{indent}static constexpr int {name}[] = {{{vals}}};\n"


def fmt_pst(values: list[int], name: str, indent: str) -> str:
    """Format a 64-element PST array with 8 values per line."""
    lines = []
    lines.append(f"{indent}static constexpr int {name}[64] = {{")
    for rank in range(8):
        row = values[rank * 8 : (rank + 1) * 8]
        vals = ", ".join(f"{v:4d}" for v in row)
        comma = "," if rank < 7 else ""
        lines.append(f"{indent}    {vals}{comma}")
    lines.append(f"{indent}}};")
    return "\n".join(lines) + "\n"


def generate() -> str:
    eng = load("engine")
    evl = load("eval")
    trn = load("training")
    dep = load("deploy")

    lines = []
    lines.append("// Auto-generated by scripts/gen_config_header.py -- DO NOT EDIT")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <cstddef>")
    lines.append("#include <string_view>")
    lines.append("")
    lines.append("namespace config {")
    lines.append("")
    lines.append(f"static constexpr float MATE_VALUE = {eng['mate_value']:.1f}f;")
    lines.append("")

    # nnue
    lines.append("namespace nnue {")
    for k in ("input_size", "hidden1_size", "hidden2_size", "output_size"):
        name = k.upper()
        lines.append(f"    static constexpr int {name} = {eng['nnue'][k]};")
    lines.append("}  // namespace nnue")
    lines.append("")

    # search
    s = eng["search"]
    lines.append("namespace search {")
    lines.append(f"    static constexpr size_t CACHE_SIZE = {s['cache_size']};")
    lines.append(
        f"    static constexpr int TIME_CHECK_INTERVAL = {s['time_check_interval']};"
    )
    lines.append(f"    static constexpr int MAX_DEPTH = {s['max_depth']};")
    lines.append(
        f"    static constexpr int QUIESCENCE_MAX_DEPTH = {s['quiescence_max_depth']};"
    )
    lines.append(
        f"    static constexpr int DEFAULT_MAX_TIME_MS = {s['default_max_time_ms']};"
    )
    lines.append(
        f"    static constexpr int TIME_ALLOCATION_DIVISOR = {s['time_allocation_divisor']};"
    )
    lines.append("")
    nm = s["null_move"]
    lines.append("    namespace null_move {")
    lines.append(f"        static constexpr int MIN_DEPTH = {nm['min_depth']};")
    lines.append(f"        static constexpr int MATE_MARGIN = {nm['mate_margin']};")
    lines.append(
        f"        static constexpr int DEEP_THRESHOLD = {nm['deep_threshold']};"
    )
    lines.append(
        f"        static constexpr int SHALLOW_REDUCTION = {nm['shallow_reduction']};"
    )
    lines.append(
        f"        static constexpr int DEEP_REDUCTION = {nm['deep_reduction']};"
    )
    lines.append("    }  // namespace null_move")
    lines.append("")
    lmr = s["lmr"]
    lines.append("    namespace lmr {")
    lines.append(
        f"        static constexpr int MIN_MOVES_SEARCHED = {lmr['min_moves_searched']};"
    )
    lines.append(f"        static constexpr int MIN_DEPTH = {lmr['min_depth']};")
    lines.append(
        f"        static constexpr int MANY_MOVES_THRESHOLD = {lmr['many_moves_threshold']};"
    )
    lines.append(
        f"        static constexpr int SHALLOW_REDUCTION = {lmr['shallow_reduction']};"
    )
    lines.append(
        f"        static constexpr int DEEP_REDUCTION = {lmr['deep_reduction']};"
    )
    lines.append("    }  // namespace lmr")
    lines.append("}  // namespace search")
    lines.append("")

    # mcts
    m = eng["mcts"]
    lines.append("namespace mcts {")
    lines.append(
        f"    static constexpr float EXPLORATION_CONSTANT = {m['exploration_constant']:.1f}f;"
    )
    lines.append(
        f"    static constexpr int MAX_SIMULATION_DEPTH = {m['max_simulation_depth']};"
    )
    lines.append(f"    static constexpr int CACHE_SIZE = {m['cache_size']};")
    lines.append(
        f"    static constexpr int DEFAULT_MAX_TIME_MS = {m['default_max_time_ms']};"
    )
    lines.append(f"    static constexpr int EVAL_FREQUENCY = {m['eval_frequency']};")
    lines.append(
        f"    static constexpr float EARLY_TERMINATION_FACTOR = {m['early_termination_factor']:.1f}f;"
    )
    lines.append(
        f"    static constexpr float PRIOR_SIGMOID_SCALE = {m['prior_sigmoid_scale']:.1f}f;"
    )
    lines.append("}  // namespace mcts")
    lines.append("")

    # bot
    b = eng["bot"]
    lines.append("namespace bot {")
    lines.append(f"    static constexpr int MAX_RETRIES = {b['max_retries']};")
    lines.append(f"    static constexpr int RETRY_DELAY_MS = {b['retry_delay_ms']};")
    lines.append(
        f"    static constexpr int HEARTBEAT_INTERVAL_MS = {b['heartbeat_interval_ms']};"
    )
    lines.append(
        f"    static constexpr int CONNECTION_TIMEOUT_MS = {b['connection_timeout_ms']};"
    )
    lines.append(
        f"    static constexpr int MAX_CONSECUTIVE_ERRORS = {b['max_consecutive_errors']};"
    )
    lines.append(f"    static constexpr int MAX_RESTARTS = {b['max_restarts']};")
    lines.append(
        f'    static constexpr std::string_view USER_AGENT = "{b["user_agent"]}";'
    )
    lines.append(
        f'    static constexpr std::string_view LICHESS_BASE_URL = "{b["lichess_base_url"]}";'
    )
    lines.append(
        f'    static constexpr std::string_view CONNECTIVITY_TEST_URL = "{b["connectivity_test_url"]}";'
    )
    lines.append("}  // namespace bot")
    lines.append("")

    # curl
    c = eng["curl"]
    lines.append("namespace curl {")
    lines.append(
        f"    static constexpr long REQUEST_TIMEOUT = {c['request_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long REQUEST_CONNECT_TIMEOUT = {c['request_connect_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long CONNECTIVITY_TIMEOUT = {c['connectivity_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long CONNECTIVITY_CONNECT_TIMEOUT = {c['connectivity_connect_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_CONNECT_TIMEOUT = {c['stream_connect_timeout']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_LOW_SPEED_LIMIT = {c['stream_low_speed_limit']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_LOW_SPEED_TIME = {c['stream_low_speed_time']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_KEEPALIVE_IDLE = {c['stream_keepalive_idle']}L;"
    )
    lines.append(
        f"    static constexpr long STREAM_KEEPALIVE_INTERVAL = {c['stream_keepalive_interval']}L;"
    )
    lines.append(f"    static constexpr long MAX_REDIRECTS = {c['max_redirects']}L;")
    lines.append("}  // namespace curl")
    lines.append("")

    # features
    ft = eng["features"]
    lines.append("namespace features {")
    lines.append(f"    static constexpr int FEATURE_SIZE = {ft['feature_size']};")
    lines.append(
        f"    static constexpr float PIECE_COUNT_DIVISOR = {ft['piece_count_divisor']:.1f}f;"
    )
    lines.append("}  // namespace features")
    lines.append("")

    # eval
    lines.append("namespace eval {")
    ind = "    "
    lines.append(fmt_int_array(evl["material_mg"], "MATERIAL_MG", ind))
    lines.append(fmt_int_array(evl["material_eg"], "MATERIAL_EG", ind))
    lines.append(fmt_int_array(evl["phase_weight"], "PHASE_WEIGHT", ind))
    # Derived: TOTAL_PHASE = 4*N + 4*B + 4*R + 2*Q = 4*1 + 4*1 + 4*2 + 2*4
    pw = evl["phase_weight"]
    total_phase = 4 * pw[1] + 4 * pw[2] + 4 * pw[3] + 2 * pw[4]
    lines.append(f"{ind}static constexpr int TOTAL_PHASE = {total_phase};")
    lines.append("")
    lines.append(fmt_int_array(evl["mobility_bonus"], "MOBILITY_BONUS", ind))

    # PSTs
    pst_names = [
        ("pst_pawn_mg", "PST_PAWN_MG"),
        ("pst_pawn_eg", "PST_PAWN_EG"),
        ("pst_knight_mg", "PST_KNIGHT_MG"),
        ("pst_bishop_mg", "PST_BISHOP_MG"),
        ("pst_rook_mg", "PST_ROOK_MG"),
        ("pst_queen_mg", "PST_QUEEN_MG"),
        ("pst_king_mg", "PST_KING_MG"),
        ("pst_king_eg", "PST_KING_EG"),
    ]
    for yaml_key, cpp_name in pst_names:
        lines.append(fmt_pst(flatten_pst(evl[yaml_key]), cpp_name, ind))

    # PST lookup arrays
    lines.append(
        f"{ind}static constexpr const int* PST_MG[] = {{PST_PAWN_MG, PST_KNIGHT_MG, PST_BISHOP_MG,"
    )
    lines.append(
        f"{ind}                                         PST_ROOK_MG, PST_QUEEN_MG, PST_KING_MG}};"
    )
    lines.append(
        f"{ind}static constexpr const int* PST_EG[] = {{PST_PAWN_EG, PST_KNIGHT_MG, PST_BISHOP_MG,"
    )
    lines.append(
        f"{ind}                                         PST_ROOK_MG, PST_QUEEN_MG, PST_KING_EG}};"
    )
    lines.append("")

    # Pawn structure
    ps = evl["pawn_structure"]
    lines.append(f"{ind}namespace pawn_structure {{")
    lines.append(f"{ind}    static constexpr int PASSED_BASE = {ps['passed_base']};")
    lines.append(
        f"{ind}    static constexpr int PASSED_RANK_SCALE = {ps['passed_rank_scale']};"
    )
    lines.append(
        f"{ind}    static constexpr int PASSED_MG_DIVISOR = {ps['passed_mg_divisor']};"
    )
    lines.append(f"{ind}    static constexpr int ISOLATED_MG = {ps['isolated_mg']};")
    lines.append(f"{ind}    static constexpr int ISOLATED_EG = {ps['isolated_eg']};")
    lines.append(f"{ind}    static constexpr int DOUBLED_MG = {ps['doubled_mg']};")
    lines.append(f"{ind}    static constexpr int DOUBLED_EG = {ps['doubled_eg']};")
    lines.append(f"{ind}}}  // namespace pawn_structure")
    lines.append("")

    # Rook file
    rf = evl["rook_file"]
    lines.append(f"{ind}namespace rook_file {{")
    lines.append(f"{ind}    static constexpr int OPEN_MG = {rf['open_mg']};")
    lines.append(f"{ind}    static constexpr int OPEN_EG = {rf['open_eg']};")
    lines.append(f"{ind}    static constexpr int SEMI_OPEN_MG = {rf['semi_open_mg']};")
    lines.append(f"{ind}    static constexpr int SEMI_OPEN_EG = {rf['semi_open_eg']};")
    lines.append(f"{ind}}}  // namespace rook_file")
    lines.append("")

    # Bishop pair
    bp = evl["bishop_pair"]
    lines.append(f"{ind}namespace bishop_pair {{")
    lines.append(f"{ind}    static constexpr int BONUS_MG = {bp['bonus_mg']};")
    lines.append(f"{ind}    static constexpr int BONUS_EG = {bp['bonus_eg']};")
    lines.append(f"{ind}}}  // namespace bishop_pair")
    lines.append("")

    # King safety
    ks = evl["king_safety"]
    lines.append(f"{ind}namespace king_safety {{")
    lines.append(
        f"{ind}    static constexpr int SHIELD_BONUS_MG = {ks['shield_bonus_mg']};"
    )
    lines.append(f"{ind}}}  // namespace king_safety")
    lines.append("}  // namespace eval")
    lines.append("")

    # self_play
    sp = trn["self_play"]
    lines.append("namespace self_play {")
    lines.append(f"    static constexpr int NUM_GAMES = {sp['num_games']};")
    lines.append(f"    static constexpr int SEARCH_DEPTH = {sp['search_depth']};")
    lines.append(f"    static constexpr int NUM_THREADS = {sp['num_threads']};")
    lines.append(f"    static constexpr int MAX_GAME_PLY = {sp['max_game_ply']};")
    lines.append(f"    static constexpr int SEARCH_TIME_MS = {sp['search_time_ms']};")
    lines.append(
        f"    static constexpr int RESIGN_THRESHOLD = {sp['resign_threshold']};"
    )
    lines.append(f"    static constexpr int RESIGN_COUNT = {sp['resign_count']};")
    lines.append("}  // namespace self_play")
    lines.append("")

    # paths
    lines.append("namespace paths {")
    lines.append(
        f'    static constexpr std::string_view MODEL_COEFFICIENTS = "{dep["paths"]["model_coefficients"]}";'
    )
    lines.append("}  // namespace paths")
    lines.append("")

    lines.append("}  // namespace config")
    lines.append("")

    return "\n".join(lines)


def main():
    content = generate()
    OUTPUT.write_text(content)
    print(f"Generated {OUTPUT}")


if __name__ == "__main__":
    main()
